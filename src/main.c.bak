#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>

#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <net/if_arp.h> // ETHER_ADDR_LEN

#include "netbsd_stack_api.h" // 包含静态库 API 头文件


#define BUFFER_SIZE 2048

int main(int argc, char *argv[]) {
    int raw_socket;
    char buffer[BUFFER_SIZE];
    struct sockaddr_ll sll;
    struct ifreq ifr;
    char *if_name = "eth0"; // 默认网卡名
    uint32_t dest_ip_addr;
    unsigned char dest_mac_addr[ETH_ALEN];

    if (argc < 3) {
        fprintf(stderr, "用法: %s <网卡名称> <目标IP地址>\n", argv[0]);
        return 1;
    }

    if_name = argv[1];
    const char *dest_ip_str = argv[2];

    // 1. 初始化 NetBSD 协议栈 (调用静态库 API)
    if (netbsd_stack_init(if_name) != 0) {
        fprintf(stderr, "NetBSD 协议栈初始化失败!\n");
        return 1;
    }
    printf("NetBSD 协议栈初始化成功, 网卡: %s\n", if_name);

    // 2. 创建 Raw Socket (不变 - 用于接收所有数据包)
    raw_socket = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (raw_socket == -1) {
        perror("socket");
        netbsd_stack_cleanup(); // 初始化失败需要清理资源
        return 1;
    }

    // 3. 获取网络接口索引 (不变)
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, if_name, IFNAMSIZ - 1);
    if (ioctl(raw_socket, SIOCGIFINDEX, &ifr) == -1) {
        perror("ioctl SIOCGIFINDEX");
        close(raw_socket);
        netbsd_stack_cleanup();
        return 1;
    }
    int if_index = ifr.ifr_ifindex;

    // 4. 绑定 Raw Socket (不变 - 接收所有协议)
    memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = if_index;
    sll.sll_protocol = htons(ETH_P_ALL);
    if (bind(raw_socket, (struct sockaddr *)&sll, sizeof(sll)) == -1) {
        perror("bind");
        close(raw_socket);
        netbsd_stack_cleanup();
        return 1;
    }
    printf("Raw socket 绑定到网卡 %s 成功, 索引: %d\n", if_name, if_index);

    // 5. 解析目标 IP 地址 (字符串转网络字节序 uint32_t)
    dest_ip_addr = inet_addr(dest_ip_str);
    if (dest_ip_addr == INADDR_NONE) {
        fprintf(stderr, "无效的目标 IP 地址: %s\n", dest_ip_str);
        close(raw_socket);
        netbsd_stack_cleanup();
        return 1;
    }
    printf("目标 IP 地址: %s (%u)\n", dest_ip_str, ntohl(dest_ip_addr));

    // **  需要获取目标 MAC 地址  **  (ARP 协议解析或静态配置, 这里先简化为静态 MAC 地址)
    // **  !!!  重要:  实际应用中需要 ARP 协议来动态获取 MAC 地址  !!!  **
    unsigned char broadcast_mac[ETH_DATA_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; // 广播 MAC 地址 (测试用)
    memcpy(dest_mac_addr, broadcast_mac, ETH_DATA_LEN); // 假设目标 MAC 是广播地址 (仅用于测试 ICMP)
    printf("目标 MAC 地址: 广播地址 (测试)\n");


    printf("开始发送 ICMP Echo 请求...\n");
    if (netbsd_send_icmp_echo(dest_mac_addr, dest_ip_addr) != 0) { // 6. 发送 ICMP Echo 请求 (调用静态库 API)
        fprintf(stderr, "发送 ICMP Echo 请求失败!\n");
        close(raw_socket);
        netbsd_stack_cleanup();
        return 1;
    }
    printf("ICMP Echo 请求已发送, 目标 IP: %s\n", dest_ip_str);


    printf("开始接收数据包...\n");
    while (1) {
        ssize_t packet_len = recvfrom(raw_socket, buffer, BUFFER_SIZE, 0, NULL, NULL);
        if (packet_len == -1) {
            perror("recvfrom");
            continue;
        }

        netbsd_process_packet(buffer, packet_len); // 7. 将接收到的数据包传递给 NetBSD 协议栈处理 (调用静态库 API)
        //  !!!  协议栈需要处理 ICMP Echo Reply, 并将结果通过某种方式通知用户程序  !!!
        //  !!!  例如, 可以通过回调函数, 或者在 netbsd_process_packet 函数内部处理 ICMP Reply 并打印  !!!

        //  !!!  当前示例代码缺少接收 ICMP Reply 的处理逻辑,  需要在静态库内部实现 ICMP Reply 的处理 !!!
        //  !!!  并在用户程序中添加相应的接收和处理机制 !!!

        //  为了简化示例,  这里先简单打印接收到的包长度
        printf("接收到数据包, 长度: %zd 字节\n", packet_len);
    }

    close(raw_socket);
    netbsd_stack_cleanup(); // 8. 清理协议栈资源 (程序退出前调用)
    return 0;
}
